{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue254;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c99608;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 import numpy as np\cb1 \
\cb3 import cvxpy as cp\cb1 \
\cb3 import scipy as sp\cb1 \
\cb3 import scipy.linalg as spla\cb1 \
\cb3 import matplotlib as mpl\cb1 \
\cb3 import control as ctrl\cb1 \
\cb3 import matplotlib.pyplot as plt\cb1 \
\cb3 from numpy import linalg as LA\cb1 \
\
\cb3 # Define the problem data...\cb1 \
\cb3 n = 2 # 2 states\cb1 \
\cb3 m = 1 # 1 input\cb1 \
\
\cb3 # Computation of matrices P and K...\cb1 \
\cb3 N = 5\cb1 \
\cb3 R = 25\cb1 \
\cb3 Pf = np.eye(2)\cb1 \
\cb3 Q = np.eye(2)\cb1 \
\cb3 A = [[0.9,1.5],[1.3,-0.7]]\cb1 \
\cb3 B = [[0.5],[0.2]]\cb1 \
\cb3 A = np.array(A)\cb1 \
\cb3 B = np.array(B)\cb1 \
\
\cb3 N = 50\cb1 \
\cb3 P = np.zeros((n, n, N+1)) # tensor\cb1 \
\cb3 K = np.zeros((m, n, N)) # tensor (3D array)\cb1 \
\cb3 P[:,:,N] = Pf\cb1 \
\
\cb3 PN11 = []\cb1 \
\cb3 PN12 = []\cb1 \
\cb3 PN22 = []\cb1 \
\cb3 i_values = []\cb1 \
\
\cb3 for i in range(N):\cb1 \
\cb3   Pcurr = P[:,:,N-i]\cb1 \
\cb3   K[:,:,N-i-1] = -sp.linalg.solve(R+B.T@Pcurr@B, B.T@Pcurr@A)\cb1 \
\cb3   P[:,:,N-i-1] = Q + A.T @ Pcurr @ A + A.T @ Pcurr @ B @ K[:,:,N-i-1]\cb1 \
\cb3   error = Pcurr - P[:,:,N-i-1]\cb1 \
\cb3   #PN12 = PN 21\cb1 \
\cb3   PN11.append(Pcurr[0,0])\cb1 \
\cb3   PN12.append(Pcurr[0,1])\cb1 \
\cb3   PN22.append(Pcurr[1,1])\cb1 \
\cb3   i_values.append(i)\cb1 \
\
\
\
\cb3 N_values = []\cb1 \
\cb3 loop=0\cb1 \
\cb3 while loop<N:\cb1 \
\cb3   N_values.append(N-i_values[loop])\cb1 \
\cb3   loop += 1\cb1 \
\
\
\cb3 print('For 2ii)\\n','for N =',N,'PN11 =',PN11[0],'PN12 =',PN12[0],'PN21 =',PN12[0],'PN22 =',PN22[0],'Therefore as seen fro the graph in 2iii the values go towards the matrix P that solves DARE as N increases and are approximately equal to it at N = 50')\cb1 \
\
\cb3 #Graph for 2iii\cb1 \
\cb3 #2iii) Graph shows that the values of PN converge to a value at higher N values\cb1 \
\
\cb3 plt.plot(N_values,PN11,N_values,PN12,N_values,PN22)\cb1 \
\cb3 plt.legend(['PN 1,1','PN 1,2','PN 2,2'])\cb1 \
\cb3 plt.xlabel('N')\cb1 \
\cb3 plt.ylabel('P')\cb1 \
\cb3 plt.savefig('2iii) P against N')\cb1 \
\cb3 plt.show()\cb1 \
\
}