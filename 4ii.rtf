{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue254;\red255\green255\blue255;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c99608;\cssrgb\c100000\c100000\c100000;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\fs28 \cf2 \cb3 import numpy as np\cb4 \
\cb3 import cvxpy as cp\cb4 \
\cb3 import scipy as sp\cb4 \
\cb3 import scipy.linalg as spla\cb4 \
\cb3 import matplotlib as mpl\cb4 \
\cb3 import control as ctrl\cb4 \
\cb3 import matplotlib.pyplot as plt\cb4 \
\cb3 from numpy import linalg as LA\cb4 \
\
\cb3 # Define the problem data...\cb4 \
\cb3 n = 2 # 2 states\cb4 \
\cb3 m = 1 # 1 input\cb4 \
\
\cb3 A = np.array([[.95, 1.5],[1.3, -0.7]])\cb4 \
\cb3 B = np.array([[0.5], [0.2]])\cb4 \
\cb3 Q = np.eye(2)\cb4 \
\cb3 R = 10\cb4 \
\cb3 Pf = np.eye(2)\cb4 \
\cb3 N = 40\cb4 \
\
\cb3 # Construct Qbar and Rbar\cb4 \
\cb3 Qbar = np.kron(np.eye(N-1), Q)\cb4 \
\cb3 Qbar = sp.linalg.block_diag(Qbar, Pf)\cb4 \
\cb3 Rbar = np.kron(np.eye(N), R)\cb4 \
\
\cb3 # Construct Abar\cb4 \
\cb3 Atemp = Abar = A\cb4 \
\cb3 for i in range(N-1):\cb4 \
\cb3   Atemp = A @ Atemp\cb4 \
\cb3   Abar = np.vstack((Abar, Atemp))\cb4 \
\
\cb3 # Construct Bbar\cb4 \
\cb3 Bbar = np.hstack((B, np.zeros((n, (N-1)*m))))\cb4 \
\cb3 for i in range(N-1):\cb4 \
\cb3   Btemp = B\cb4 \
\cb3   B_current_line = B\cb4 \
\cb3   for j in range(i+1):\cb4 \
\cb3     Btemp = A @ Btemp\cb4 \
\cb3     B_current_line = np.hstack((Btemp, B_current_line))\cb4 \
\cb3   B_current_line = np.hstack((B_current_line, np.zeros((n, (N-j-2)*m))))\cb4 \
\cb3   Bbar = np.vstack((Bbar, B_current_line))\cb4 \
\
\
\cb3 N = 40\cb4 \
\cb3 P = np.zeros((n, n, N+1)) # tensor\cb4 \
\cb3 K = np.zeros((m, n, N)) # tensor (3D array)\cb4 \
\cb3 P[:,:,N] = Pf\cb4 \
\
\cb3 xmin = np.array([-1,-1])\cb4 \
\cb3 xmax = np.array([1, 1])\cb4 \
\cb3 umin = np.array([-1])\cb4 \
\cb3 umax = np.array([1])\cb4 \
\
\cb3 # Problem statement\cb4 \
\cb3 # -----------------------------\cb4 \
\cb3 x0 = cp.Parameter(n) # <--- x is a parameter of the optimisation problem P_N(x)\cb4 \
\cb3 u_seq = cp.Variable((m, N)) # <--- sequence of control actions\cb4 \
\cb3 x_seq = cp.Variable((n, N+1))\cb4 \
\
\cb3 cost = 0\cb4 \
\cb3 constraints = [x_seq[:, 0] == x0] # x_0 = x\cb4 \
\
\cb3 for t in range(N-1):\cb4 \
\cb3   xt_var = x_seq[:, t] # x_t\cb4 \
\cb3   ut_var = u_seq[:, t] # u_t\cb4 \
\cb3   cost += 0.5*(cp.quad_form(xt_var, Q) + R*ut_var**2)\cb4 \
\cb3   # dynamics, xmin <= xt <= xmax, umin <= ut <= umax\cb4 \
\cb3   constraints += [x_seq[:, t+1] == A@xt_var + B@ut_var, \cb4 \
\cb3                   xmin <= xt_var,\cb4 \
\cb3                   xt_var <= xmax,\cb4 \
\cb3                   umin <= ut_var,\cb4 \
\cb3                   ut_var <= umax]\cb4 \
\
\
\cb3 xN = x_seq[:, N-1]\cb4 \
\cb3 cost += 0.5*cp.quad_form(xN, Q) # terminal cost\cb4 \
\cb3 constraints += [xmin <= xN, xN <= xmax] # terminal constraints (xmin <= xN <= xmax)\cb4 \
\
\cb3 # Solution\cb4 \
\cb3 # -----------------------------\cb4 \
\cb3 x0.value = np.array([0.02, 0.05])\cb4 \
\cb3 problem = cp.Problem(cp.Minimize(cost), constraints)\cb4 \
\cb3 problem.solve()\cb4 \
\
\cb3 print("MPC control action =",u_seq.value)\cb4 \
\
\
\cb3 # Plotting of solution\cb4 \
\cb3 # -----------------------------\cb4 \
\cb3 x_star = x_seq.value\cb4 \
\cb3 plt.plot(x_star.T)\cb4 \
\cb3 plt.rcParams['font.size'] = '14'\cb4 \
\cb3 plt.xlabel('Time, t')\cb4 \
\cb3 plt.ylabel('States')\cb4 \
\cb3 plt.savefig('States against Time')\cb4 \
\cb3 plt.cla()\cb4 \
\cb3 plt.clf()\cb4 \
\
\cb3 u_star = u_seq.value\cb4 \
\cb3 plt.plot(u_star.T)\cb4 \
\cb3 plt.xlabel('Time, t')\cb4 \
\cb3 plt.ylabel('Input')\cb4 \
\cb3 plt.savefig('Input against Time')\cb4 \
\cb3 plt.cla()\cb4 \
\cb3 plt.clf()\cb4 \
\
\
\cb3 P, _, K = ctrl.dare(A, B, Q, R)\cb4 \
\cb3 K = - K\cb4 \
\
\cb3 x_star=np.array([[1],[1]])\cb4 \
\
\cb3 V_star_inf = (1/2)*(x_star.T)@P@x_star\cb4 \
\cb3 #print(V_star_inf[0,0])\cb4 \
\
\cb3 V_values = []\cb4 \
\cb3 x = np.array([[1],[2]])\cb4 \
\cb3 u = K @ x\cb4 \
\cb3 x_cache = x\cb4 \
\cb3 u_cache = u\cb4 \
\cb3 x_plot = []\cb4 \
\cb3 u_plot = []\cb4 \
\
\cb3 Acl = A + B@K\cb4 \
\cb3 for t in range(100):\cb4 \
\cb3   u = K @ x\cb4 \
\cb3   x = A @ x + B @ u\cb4 \
\cb3   V_star_N_x = 0.5*(x.T @ P @ x)\cb4 \
\cb3   V_values.append(V_star_N_x[0,0])\cb4 \
\cb3   x_plot.append(x[1])\cb4 \
\cb3   x_cache = np.concatenate((x_cache, x))\cb4 \
\cb3   u_cache = np.concatenate((u_cache, u))\cb4 \
\cb3   x_plot.append(x[0])\cb4 \
\cb3   u_plot.append(u[0])\cb4 \
\
\cb3 #For 4i)\cb4 \
\cb3 plt.plot(x_cache)\cb4 \
\cb3 plt.ylabel('State, x_t')\cb4 \
\cb3 plt.xlabel('Time, t')\cb4 \
\cb3 plt.savefig('States, x_t againt Time')\cb4 \
\cb3 plt.cla()\cb4 \
\cb3 plt.clf()\cb4 \
\
\cb3 plt.plot(u_cache)\cb4 \
\cb3 plt.ylabel('Control actions, u_t')\cb4 \
\cb3 plt.xlabel('Time, t')\cb4 \
\cb3 plt.savefig('Control actions, u_t against Time')\cb4 \
\cb3 plt.cla()\cb4 \
\cb3 plt.clf()\cb4 \
\
\cb3 #For 4ii)\cb4 \
\cb3 plt.plot(V_values)\cb4 \
\cb3 plt.ylabel('V N star')\cb4 \
\cb3 plt.xlabel('State, x_t')\cb4 \
\cb3 plt.savefig('V N star againt Time')\cb4 \
\cb3 plt.cla()\cb4 \
\cb3 plt.clf()\cb4 \
}